/**
 * @author Jason Reynolds
 * 
 * @param inputM - the matrix part of the equation Ax=b to be solved for x. Is strictly lower triangular in lsolve (see lusolve for other)
 * @param inputCol - the column part, b, of the equation Ax = b, to be solved for x. Has to be of size A.length
 * @returns - Matrix that has dimensions A.length x 1 (column vector) with the answers to the linear equation systems ie it is unknown x in Ax=b
 * 
 * Function similar to lusolve - it solves an nxn matrix exquation Ax = b for x. May work faster but only allows lower triangular matrices as input
 */

*import math: is_tril
*import math: ndim

function lsolve(inputM, input_col) {
    let in_type_M = (inputM instanceof Mat);
    let raw_in = (in_type_M) ? inputM.clone() : inputM;
    let in_type_col = (input_col instanceof Mat);
    let raw_in_col = (in_type_col) ? input_col.clone() : input_col;


    //if any input is Mat, turn it down into raw array
    if (inputM instanceof Mat) {
        raw_in = raw_in.val;
    }
    if (input_col instanceof Mat) {
        raw_in_col = raw_in_col.val;
    }

    //make sure that the input array is lower triangular
    if (!(is_tril(raw_in))) {
        throw new Error('Non lower triangular matrix in input');
    }
    //make sure they are correct dimensions, has to be square matrix, and column length is === to matrix length
    if (raw_in.length === 0 || raw_in[0].length === 0 || !(raw_in.length === raw_in[0].length) || !(raw_in_col.length === raw_in.length)) {
        throw new Error('Wrong dimensions. Need nxn matrix, may want to try lusolveAll or check column vector');
    }
    //see if the column input is 1dimensional (a vector) and has 1 row (a column), we already checked for #columns 
    if (!(ndim(raw_in_col) === 1) || !(raw_in_col[0].length === 1)) {
        throw new Error('Column vector is not of correct input. Make sure it is a column and not row vector, 1 dimensional')
    }
    //make sure the column vector is 1d
    //define the result to be the lusolve output ie the solution
    let result = mathjs.lsolve(raw_in, raw_in_col);
    //return it as a Mat object
    return new Mat(result);
}